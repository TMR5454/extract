#include <algorithm>
#include <cstdio>
#include <fstream>
#include <iostream>
#include <regex>
#include <vector>

class node {
public:
  unsigned long addr;
  std::string byfunc;
  unsigned int line;
  unsigned long alloc_size;

  node() = default;
  node(unsigned long lu, unsigned long size, unsigned int l, const char *f)
      : addr(lu), alloc_size(size), line(l), byfunc(f){};
  node(unsigned long lu) : addr(lu), line(0){};
  bool operator==(const node &rhs) const { return (this->addr == rhs.addr); }
};

class parser {
  std::ifstream fs;
  std::vector<node> v;

public:
  parser() = default;
  parser(std::string filename) { fs.open(filename); }
  void exec(void);
  void dump(void);
};

auto hexstr2ul(std::string s) -> unsigned long {
  unsigned long ret;

  try {
    ret = std::stoul(s, nullptr, 16);
  } catch (std::exception &e) {
    ret = 0;
  }

  return ret;
}

auto parser::exec(void) -> void {

  std::regex rgx_malloc(".*malloc\\(([0-9]+)\\).*= (0x[0-9a-f]+)");
  std::regex rgx_calloc(".*calloc\\(([0-9]+), ([0-9]+)\\).*= (0x[0-9a-f]+)");
  std::regex rgx_realloc(".*realloc\\((.+), ([0-9]+)\\).*= (0x[0-9a-f]+)");
  std::regex rgx_free(".*free\\((0x[0-9a-f]+)\\).*");
  std::smatch match;
  std::string line;
  std::stringstream ss;
  unsigned long int x;
  unsigned int line_counter = 0;
  while (std::getline(fs, line)) {
    line_counter++;
    line.erase(std::remove(line.begin(), line.end(), '\n'),
               line.end()); // remove '\n'
    if (std::regex_match(line, match, rgx_malloc)) {
      node tmp(hexstr2ul(match[2].str()), hexstr2ul(match[1].str()), line_counter, "malloc()");
      v.push_back(std::move(tmp));
      //::fprintf(stderr, "%lu\n", hexstr2ul(match[1].str()));

    } else if (std::regex_match(line, match, rgx_realloc)) {
      node tmp(hexstr2ul(match[1].str()));
      auto iter = std::find(v.begin(), v.end(), tmp);
      if (iter != v.end()) {
        v.erase(iter);
      } else {
        unsigned long address = hexstr2ul(match[1].str());
        if (address) {
          //::printf("NON REALLOC() 0x%lx\n", address);
        }
      }
      std::string s("realloc()");
      s.append(match[1].str());
      node tmp2(hexstr2ul(match[3].str()), hexstr2ul(match[2].str()), line_counter, s.c_str());
      v.push_back(std::move(tmp2));
    } else if (std::regex_match(line, match, rgx_free)) {
      node tmp(hexstr2ul(match[1].str()));
      auto iter = std::find(v.begin(), v.end(), tmp);
      if (iter != v.end()) {
        v.erase(iter);
      } else {
        unsigned long address = hexstr2ul(match[1].str());
        if (address) {
          //::printf("NON FREE() 0x%lx\n", address);
        }
      }
    } else if (std::regex_match(line, match, rgx_calloc)) {
      unsigned long size = hexstr2ul(match[1].str()) * hexstr2ul(match[2].str());
      node tmp(hexstr2ul(match[3].str()), size, line_counter, "calloc()");
      v.push_back(std::move(tmp));
    }
  }
}

auto parser::dump(void) -> void {
  for (auto i : v) {
    ::printf("0x%lx size %lu by %s\n", i.addr, i.alloc_size, i.byfunc.c_str());
  }
}

auto main(int argc, char *argv[]) -> int {

  if (argc != 2) {
    ::printf("usage: %s [target-file.txt]\n\n", argv[0]);
    ::printf("target-file.txt is generated by \"ex.) ltrace -p "
             "TARGET_PROCESS_PID "
             "-e malloc+free+calloc+realloc-@libc* -o target_file.txt\"\n");
    return 0;
  }

  try {
    auto target_file = std::string(argv[1]);
    parser p(target_file);

    p.exec();
    p.dump();
  } catch (const std::exception &e) {
    ::printf("error %s\n", e.what());
  }

  return 0;
}
